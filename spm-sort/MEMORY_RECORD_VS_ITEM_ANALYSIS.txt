================================================================================
MEMORY ANALYSIS: Record Reading and Item Formation Process
================================================================================

1. DATA STRUCTURES INVOLVED
================================================================================

A. struct Record (on disk format - 12 bytes, padded to 16 bytes):
   ┌──────────────┬──────────────┬──────────────┐
   │  uint64_t    │  uint32_t    │  padding     │
   │  key         │  len         │  (4 bytes)   │
   │  8 bytes     │  4 bytes     │              │
   └──────────────┴──────────────┴──────────────┘
   Total: 16 bytes in memory (12 bytes actual + 4 bytes padding)
   
   Purpose: Temporary structure to read the header (key + length)

B. struct Item (in-memory format - 16 bytes):
   ┌──────────────┬────────────────────────────────┐
   │  uint64_t    │  CompactPayload                │
   │  key         │  (uint8_t *data_)              │
   │  8 bytes     │  8 bytes (pointer)             │
   └──────────────┴────────────────────────────────┘
   Total: 16 bytes per Item object
   
   Purpose: Working structure for sorting and processing
   
   The CompactPayload pointer points to:
   ┌──────────────┬────────────────────────────────┐
   │  uint32_t    │  payload bytes                 │
   │  size        │  (N bytes)                     │
   │  4 bytes     │                                │
   └──────────────┴────────────────────────────────┘
   Additional heap allocation: 4 + N bytes

================================================================================
2. READING PROCESS - STEP BY STEP
================================================================================

FILE FORMAT on disk:
┌────────────────────────────────────────────────────────────────┐
│ [key:8][len:4] [payload:N] [key:8][len:4] [payload:N] ...     │
└────────────────────────────────────────────────────────────────┘

STEP-BY-STEP for reading ONE record:

Location: main.cpp, read_record() function
────────────────────────────────────────────────────────────────

Step 1: Create temporary Record on stack
────────────────────────────────────────
Code: Record record{};

Stack memory:
┌──────────────────────────────────┐
│  Record record                   │
│  ┌──────────┬─────────┬────────┐ │
│  │ key: 0   │ len: 0  │ padding│ │
│  │ 8 bytes  │ 4 bytes │ 4 bytes│ │
│  └──────────┴─────────┴────────┘ │
└──────────────────────────────────┘
Memory used: 16 bytes (stack)

Step 2: Read Record header from file
─────────────────────────────────────
Code: stream_in.read(reinterpret_cast<char *>(&record), sizeof(record));

After read (example with key=12345, len=32):
┌──────────────────────────────────┐
│  Record record                   │
│  ┌──────────┬─────────┬────────┐ │
│  │ key:12345│ len: 32 │ padding│ │
│  │ 8 bytes  │ 4 bytes │ 4 bytes│ │
│  └──────────┴─────────┴────────┘ │
└──────────────────────────────────┘
Memory used: 16 bytes (stack) - SAME
I/O: Read 12 bytes from disk (key + len only)

Step 3: Allocate CompactPayload
────────────────────────────────
Code: payload_out.resize(record.len);

This calls CompactPayload::resize(32):
  - Allocates: new uint8_t[4 + 32] = 36 bytes on heap
  - Stores size (32) in first 4 bytes
  
Heap memory:
┌────────────────────────────────────────────────────────┐
│  [uint32_t: 32] [payload space: 32 bytes uninitialized]│
│   4 bytes         32 bytes                             │
└────────────────────────────────────────────────────────┘
Memory used: 36 bytes (heap)

The payload_out.data_ pointer now points to this heap memory.

Step 4: Read payload bytes from file
─────────────────────────────────────
Code: stream_in.read(reinterpret_cast<char *>(payload_out.data()), record.len);

Reads 32 bytes directly into the heap memory (after the size field):
┌────────────────────────────────────────────────────────┐
│  [uint32_t: 32] [payload data: 32 bytes actual data]   │
│   4 bytes         32 bytes                             │
└────────────────────────────────────────────────────────┘
Memory used: 36 bytes (heap) - SAME
I/O: Read 32 bytes from disk

Step 5: Return key and payload_out
───────────────────────────────────
Code: key_out = record.key;
      return static_cast<bool>(stream_in);

The Record struct goes out of scope (stack memory freed).
Only the key (uint64_t) and payload_out (CompactPayload) remain.

Step 6: Create Item and move payload
─────────────────────────────────────
Code: items.push_back(Item{key, std::move(payload)});

Creates an Item:
┌─────────────────────────────────────┐
│  Item                               │
│  ┌──────────┬────────────────────┐  │
│  │ key:     │ CompactPayload     │  │
│  │ 12345    │ data_ -> heap      │  │
│  │ 8 bytes  │ 8 bytes (pointer)  │  │
│  └──────────┴────────────────────┘  │
└─────────────────────────────────────┘
Memory used: 16 bytes (in vector) + 36 bytes (heap)
Total: 52 bytes per item with 32-byte payload

The std::move() transfers ownership of the heap memory without copying!

================================================================================
3. MEMORY USAGE BREAKDOWN FOR ONE ITEM
================================================================================

During read_record() execution:
──────────────────────────────────
Stack:
  - Record record               : 16 bytes (temporary)
  - uint64_t key                : 8 bytes (temporary)
  - CompactPayload payload      : 8 bytes (temporary, becomes part of Item)
  Total stack during read       : 32 bytes (temporary)

Heap (persists after read):
  - CompactPayload data         : 4 + 32 = 36 bytes
  
After Item creation:
────────────────────
Item in vector:
  - Item.key                    : 8 bytes
  - Item.payload.data_          : 8 bytes (pointer)
  Total per Item object         : 16 bytes
  
Heap allocation:
  - [size + payload data]       : 4 + 32 = 36 bytes
  
TOTAL PER ITEM IN MEMORY: 16 + 36 = 52 bytes

================================================================================
4. COMPARISON: Record vs Item Memory Usage
================================================================================

A. How many Records are created?
─────────────────────────────────
Answer: ONE temporary Record per read_record() call
Lifetime: Only during the read operation (stack-allocated)
Memory: 16 bytes (freed immediately after reading)

B. How many Items are created?
───────────────────────────────
Answer: ONE Item per record, stored in vector
Lifetime: Entire sorting operation
Memory: 16 bytes + (4 + payload_size) heap bytes

C. Are Records stored alongside Items?
───────────────────────────────────────
Answer: NO! The Record is a TEMPORARY structure.
Flow:
  1. Read Record from disk (temporary 16 bytes on stack)
  2. Extract key and len from Record
  3. Create Item with key and allocate payload
  4. Record is destroyed (stack memory freed)
  5. Only Item remains in memory

D. Memory efficiency:
─────────────────────
For 100M items with 32-byte payloads:

Items only (no duplicate Records):
  - Item objects       : 100M × 16 bytes = 1,600 MB
  - Heap allocations   : 100M × 36 bytes = 3,600 MB
  - Total             : 5,200 MB
  - Actual measured   : 3,375 MB (OS optimizations + accounting)

If we stored Records alongside Items (hypothetical):
  - Record objects     : 100M × 16 bytes = 1,600 MB (WASTED!)
  - Item objects       : 100M × 16 bytes = 1,600 MB
  - Heap allocations   : 100M × 36 bytes = 3,600 MB
  - Total             : 6,800 MB (30% MORE!)

So we are NOT duplicating data. Record is just a reading intermediary.

================================================================================
5. VISUAL: Complete Flow for ONE Item (32-byte payload)
================================================================================

┌─────────────────────────────────────────────────────────────────────┐
│ DISK FILE                                                           │
│ [key:8][len:4][payload:32] ──────────────────────────┐             │
└───────────────────────────────────────────────────────│─────────────┘
                                                        │
                                                        ▼ read
┌─────────────────────────────────────────────────────────────────────┐
│ STACK (temporary, during read_record())                            │
│ ┌────────────────────────┐                                         │
│ │ Record record          │  16 bytes                               │
│ │ ┌────────┬──────────┐  │                                         │
│ │ │key:12345│len:32   │  │                                         │
│ │ └────────┴──────────┘  │                                         │
│ └────────────────────────┘                                         │
│                              ─────extract────┐                     │
│ ┌────────────────────────┐                  │                     │
│ │ uint64_t key = 12345   │  8 bytes         │                     │
│ └────────────────────────┘                  │                     │
│                                              │                     │
│ ┌────────────────────────┐                  │                     │
│ │ CompactPayload payload │  8 bytes         │                     │
│ │ (data_ pointer)        │                  │                     │
│ └─────────│──────────────┘                  │                     │
│           │ points to heap                  │                     │
└───────────│─────────────────────────────────│─────────────────────┘
            │                                 │
            ▼ allocate                        ▼ combine
┌─────────────────────────────────────────────────────────────────────┐
│ HEAP (persistent)                                                   │
│ ┌──────────────────────────────────────────┐                       │
│ │ [uint32_t:32][payload data:32 bytes]     │  36 bytes            │
│ └──────────────────────────────────────────┘                       │
│           ▲                                                         │
│           │ owned by Item.payload.data_                            │
└───────────│─────────────────────────────────────────────────────────┘
            │
┌───────────│─────────────────────────────────────────────────────────┐
│ VECTOR<ITEM> (persistent)                                           │
│ ┌─────────────────────────────────────────┐                        │
│ │ Item                                    │  16 bytes in vector    │
│ │ ┌────────────┬─────────────────────┐    │                        │
│ │ │key: 12345  │ CompactPayload      │    │                        │
│ │ │            │ data_ ──────────────┼────┤──> points to heap     │
│ │ │ 8 bytes    │ 8 bytes (pointer)   │    │                        │
│ │ └────────────┴─────────────────────┘    │                        │
│ └─────────────────────────────────────────┘                        │
└─────────────────────────────────────────────────────────────────────┘

TOTAL PERSISTENT MEMORY: 16 (Item) + 36 (heap) = 52 bytes per item

================================================================================
6. SUMMARY
================================================================================

Q: How many Records are created besides Items?
A: ZERO persistent Records. One temporary Record per read (stack-allocated,
   immediately destroyed after extraction).

Q: How are Items formed using Record?
A: 
   1. Record is read from disk (key + len)
   2. Key is extracted directly
   3. CompactPayload allocates heap memory based on len
   4. Payload bytes are read directly into CompactPayload's heap memory
   5. Item is constructed with key and CompactPayload (moved, not copied)
   6. Record is destroyed (no longer needed)

Q: Total memory per Item?
A: 16 bytes (Item object) + (4 + N) bytes (heap allocation for payload)
   For 32-byte payload: 52 bytes total

Q: Memory overhead?
A: 
   - Key: 8 bytes (necessary)
   - Pointer: 8 bytes (CompactPayload overhead)
   - Size: 4 bytes (stored with payload data)
   - Payload: 32 bytes (actual data)
   - Total overhead: 20 bytes (38% overhead)
   
   Compare to std::vector:
   - Additional 16 bytes overhead (capacity + size fields)
   - Would be 68 bytes total (56% overhead)

Q: Are we processing Items or Records?
A: We process ITEMS exclusively. Records are only a transient reading format.
   The entire sorting, merging, and writing operations work with Items.

================================================================================
END OF ANALYSIS
================================================================================
