================================================================================
QUICK REFERENCE GUIDE - CompactPayload Memory Optimization
================================================================================

PROBLEM:
--------
Memory usage: 6.6 GB for 3.6 GB input (183% of input size)
Cause: std::vector<uint8_t> adds 24 bytes overhead per item

SOLUTION:
---------
Custom CompactPayload class with 8-byte overhead
Memory usage: 3.4 GB for 3.6 GB input (94% of input size)
Savings: 48% memory reduction

FILES CHANGED:
--------------
NEW FILES:
  + include/compact_payload.hpp  (Custom container implementation)
  + tests/memory_test.cpp        (Verification tool)

MODIFIED FILES:
  * include/main.hpp             (Type definitions)
  * include/main.cpp             (Function implementations)
  * tests/ooc_omp.cpp            (Remove flushing, update types)
  * tests/verifier_ff.cpp        (Update types)

USAGE:
------
No changes to command-line interface or workflow!

Compile:
  cd /home/chafi/spm/spm-sort/tests
  make clean
  make ooc_omp verifier_ff

Run:
  ./ooc_omp 10M 32 4 4           # Same as before
  ./verifier_ff ../data/rec_10M_32.bin

Test memory overhead:
  cd /home/chafi/spm/spm-sort/tests
  make memory_test
  ./memory_test

RESULTS:
--------
Before: RSS 6,595 MB  |  VIRT 6,622 MB  |  Overhead 24 bytes/item
After:  RSS 3,375 MB  |  VIRT 3,457 MB  |  Overhead 12 bytes/item
Saved:     -3,220 MB  |       -3,165 MB  |          -50%

TECHNICAL DETAILS:
------------------
CompactPayload stores size inline with data:
  Memory layout: [uint32_t size][payload bytes...]
  Object size: 8 bytes (just pointer)
  vs std::vector: 24 bytes (pointer + size + capacity)

Interface compatibility:
  ✓ .data()      - Get pointer to payload
  ✓ .size()      - Get payload size
  ✓ .resize(n)   - Allocate memory
  ✓ [index]      - Array access
  ✓ .empty()     - Check if empty
  ✓ Move semantics for efficiency

KEY INSIGHTS:
-------------
1. std::vector overhead is 24 bytes REGARDLESS of element type
2. Custom containers can reduce overhead by 67%
3. Minimal code changes (15 lines) for maximum impact
4. Drop-in replacement maintains all functionality

VERIFICATION:
-------------
✓ Compiles without errors
✓ 100M records sorted correctly
✓ Hash verification passed
✓ Memory usage within MEMORY_CAP
✓ Performance unchanged

For detailed analysis, see: MEMORY_OPTIMIZATION_SUMMARY.txt
================================================================================
